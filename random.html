<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Random Wheel Selector</title>
<style>
body {
  background-color: #121212;
  font-family: sans-serif;
  color: white;
  margin: 0;
  padding: 20px;      
}

#container {
  display: flex;
  flex-direction: column;
}

.component-wrapper {
  position: relative;
  margin: 10px 0;
  border: 2px solid transparent;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  transition: transform 0.2s ease;
}

/* Iframe styling */
iframe {
  border: none;
  width: 100%;
  overflow: hidden;
}

/* Remove button styling */
.remove-btn {
  position: absolute;
  top: 8px;
  right: 8px;
  background: #9370DB;
  border: none;
  color: white;
  padding: 6px 10px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  z-index: 10;
}
.remove-btn:hover { background: #A080E0; }

/* Drag handle styling */
.drag-handle {
  position: absolute;
  top: 8px;
  left: 8px;
  background: #444;
  border: none;
  color: white;
  padding: 6px 10px;
  border-radius: 6px;
  cursor: grab;
  font-size: 16px;
  z-index: 10;
}
.drag-handle:active { cursor: grabbing; }

/* Tooltips */
#add::after,
.remove-btn::after,
.drag-handle::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: 120%;
  left: 50%;
  transform: translateX(-50%);
  background-color: #555;
  color: white;
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 11px;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease, transform 0.3s ease;
  z-index: 1001;
}
#add:hover::after,
.remove-btn:hover::after,
.drag-handle:hover::after {
  opacity: 1;
  transform: translateX(-50%) translateY(-4px);
}

/* Ghost element for drag */
.drag-ghost {
  position: absolute;
  pointer-events: none;
  opacity: 0.7;
  border: 2px dashed #9370DB;
  border-radius: 8px;
  background-color: #222;
  z-index: 1000;
}
</style>
</head>
<body>

<div id="container"></div>
<button id="add" data-tooltip="Add a wheel to the page">Add wheel</button>

<script>
const container = document.getElementById('container');
const addBtn = document.getElementById('add');

let dragItem = null;
let ghost = null;
let offsetY = 0;

// Logical order array
let orderArray = [];

addBtn.addEventListener('click', () => {
  const wrapper = document.createElement('div');
  wrapper.className = 'component-wrapper';
  wrapper.dataset.id = Date.now(); // unique id
  orderArray.push(wrapper.dataset.id);

  const frame = document.createElement('iframe');
  frame.src = "wheel.html";

  const removeBtn = document.createElement('button');
  removeBtn.className = 'remove-btn';
  removeBtn.textContent = '✖';
  removeBtn.setAttribute('data-tooltip', 'Remove this wheel');
  removeBtn.addEventListener('click', () => {
    container.removeChild(wrapper);
    orderArray = orderArray.filter(id => id !== wrapper.dataset.id);
    updateOrder();
  });

  const dragHandle = document.createElement('button');
  dragHandle.className = 'drag-handle';
  dragHandle.textContent = '≡';
  dragHandle.setAttribute('data-tooltip', 'Drag to reorder');

  wrapper.appendChild(dragHandle);
  wrapper.appendChild(removeBtn);
  wrapper.appendChild(frame);
  container.appendChild(wrapper);

  // Auto-size iframe
  frame.onload = () => {
    const doc = frame.contentWindow.document;
    doc.documentElement.style.overflow = 'hidden';
    frame.style.height = doc.documentElement.scrollHeight + "px";
  };

  // Drag events
  dragHandle.addEventListener('mousedown', e => {
    dragItem = wrapper;
    const rect = wrapper.getBoundingClientRect();
    offsetY = e.clientY - rect.top;

    ghost = wrapper.cloneNode(true);
    ghost.classList.add('drag-ghost');
    ghost.style.width = rect.width + "px";
    ghost.style.height = rect.height + "px";
    ghost.style.top = rect.top + "px";
    ghost.style.left = rect.left + "px";
    document.body.appendChild(ghost);

    wrapper.style.opacity = "0.5";

    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
    e.preventDefault();
  });
});

function onMouseMove(e) {
  if (!ghost) return;
  ghost.style.top = e.clientY - offsetY + "px";

  // Determine closest wrapper
  const wrappers = Array.from(container.children).filter(c => c !== dragItem);
  let closest = null;
  let closestDistance = Infinity;

  wrappers.forEach(w => {
    const rect = w.getBoundingClientRect();
    const midY = rect.top + rect.height / 2;
    const distance = Math.abs(e.clientY - midY);
    if (distance < closestDistance) {
      closestDistance = distance;
      closest = w;
    }
  });

  if (closest) {
    const idx = orderArray.indexOf(closest.dataset.id);
    orderArray = orderArray.filter(id => id !== dragItem.dataset.id);
    orderArray.splice(idx, 0, dragItem.dataset.id);
    updateOrder();
  }
}

function onMouseUp() {
  if (!ghost) return;
  dragItem.style.opacity = "1";
  ghost.remove();
  ghost = null;
  dragItem = null;

  document.removeEventListener('mousemove', onMouseMove);
  document.removeEventListener('mouseup', onMouseUp);
}

// Update wrapper positions using CSS order
function updateOrder() {
  container.querySelectorAll('.component-wrapper').forEach(wrapper => {
    wrapper.style.order = orderArray.indexOf(wrapper.dataset.id);
  });
}
</script>

</body>
</html>
